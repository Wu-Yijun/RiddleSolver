const web_data_path = "./designer/assets/web-of-data.txt";

/**
 * This is the helper function that decode web of data mapping relation
 */
class WebDecoder {
  // be careful that size is half size of the table
  size: number;
  // from -size to size [y][x]
  private readonly table: number[][];
  constructor(size: number = 100) {
    // init
    this.size = size;
    this.table = Array.from(
      { length: size * 2 + 1 },
      (_) => Array.from({ length: size * 2 + 1 }, (_) => -1),
    );
    // get digits
    const digits = this.sqrt3_2((size * 2 + 1) ** 2);
    // fill table
    let x = 0, y = 0;
    const dir = [1, 0];
    let step = 0;
    let index = 0, stride = 1;
    while (Math.abs(x) <= size && Math.abs(y) <= size) {
      this.table[y + size][x + size] = digits[step];
      step += 1;
      index += 1;
      x += dir[0];
      y += dir[1];
      if (index === stride) {
        const tmp = dir[1];
        dir[1] = dir[0];
        dir[0] = -tmp;
        index = 0;
        if (dir[1] === 0) {
          stride += 1;
        }
      }
    }
  }
  get_table(): string {
    return this.table.map((l) => l.join("")).join("\n");
  }
  private sqrt_bv(n: bigint, len: bigint): bigint {
    let sqrt = BigInt(0);
    let shift = len;
    while (shift >= BigInt(0)) {
      const tmp = ((sqrt << BigInt(1)) + (BigInt(1) << BigInt(shift))) <<
        BigInt(shift);
      if (tmp <= n) {
        sqrt += BigInt(1) << BigInt(shift);
        n -= tmp;
      }
      shift -= BigInt(1);
    }
    return sqrt;
  }
  private sqrt3_2(digits: number): number[] {
    // this is also sqrt(6 * 2 ^ 2(digits - 1))
    const num = BigInt(6) << BigInt(2 * (digits - 2));
    const res = this.sqrt_bv(num, BigInt(digits - 1));
    return res.toString(2).split("").map((x) => parseInt(x));
  }
  public decode(x: number, y: number, len: number): number[] | null {
    if (
      (x < -this.size || x + len - 1 > this.size) ||
      (y < -this.size || y > this.size)
    ) {
      return null;
    }
    return this.table[y + this.size].slice(x + this.size, x + this.size + len);
  }
  public default_rule(): Map<string, [number, number, number]> {
    const rule = new Map<string, [number, number, number]>();
    Deno.readTextFileSync(web_data_path).trim().split("\n").forEach((line) => {
      const [name, x, y, len] = line.trim().split(/,?[ ]\(?|\)/g);
      rule.set(name, [parseInt(x), parseInt(y), parseInt(len)]);
    });
    return rule;
  }
  public default_mapping_relation(): MappingRelation {
    const rule = this.default_rule();
    const encode = new Map<string, string>();
    const decode = new Map<string, string>();
    for (const [character, [y, x, len]] of rule) {
      const rule: string = this.decode(x, y, len)!.join("");
      encode.set(character, rule);
      decode.set(rule, character);
    }
    return { encode, decode };
  }
}

interface MappingRelation {
  // from character A-Z to Nise code(Binary)
  encode: Map<string, string>;
  // from binary to A-Z
  decode: Map<string, string>;
}

/**
 * This is the Nise Code to decode sentences.
 * The mapping rule is generated by above decoder.
 * Once you got a mapping relation, you do not need to generate it again.
 */
class NiseCode {
  map: MappingRelation;
  constructor() {
    this.map = new WebDecoder().default_mapping_relation();
  }
}

Deno.test("NiseDecoder", () => {
  // const web = new WebDecoder();
  // console.log(web.get_table());
  const nise = new NiseCode();
  console.log(nise);
});

import * as nise_export from "./nise-code.ts";
import { assertEquals } from "jsr:@std/assert";
Deno.test("Real Nise Code", () => {
  const nise = new NiseCode();
  const coder = new nise_export.NiseCode(
    "./designer/assets/nise_code.txt",
    "code",
  );
  const tree: [string, string][] = [];
  coder.get_tree(tree);
  // console.log(tree);
  // console.log(nise);
  for (const [name, code] of tree) {
    assertEquals(nise.map.decode.get(code), name);
    assertEquals(nise.map.encode.get(name), code);
    console.log("OK:", name, code);
  }
});

Deno.test("Web of Data", () => {
  const nise = new nise_export.NiseCode(nise_export.nise_code_path, "code");
  console.log(nise.sentence("24038 -1807455 778 256065152 -7912 86 -237865."));
});

export { NiseCode, WebDecoder };
