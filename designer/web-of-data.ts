/**
 * This is the helper funtion that decode web of data mappping relation
 */
class WebDecoder {
  // be careful that size is half size of the table
  size: number;
  // from -size to size [y][x]
  private table: number[][];
  constructor(size: number = 100) {
    // init
    this.size = size;
    this.table = Array.from(
      { length: size * 2 + 1 },
      (_) => Array.from({ length: size * 2 + 1 }, (_) => -1),
    );
    // get digits
    const digits = this.sqrt3_2((size * 2 + 1) ** 2);
    // console.log(digits.join(""));
    // fill table
    let x = 0, y = 0;
    const dir = [1, 0];
    let step = 0;
    let index = 0, stride = 1;
    while (Math.abs(x) <= size && Math.abs(y) <= size) {
      // console.log(x, y, step, index, stride);
      // console.log(x, y, step, index, stride);
      this.table[y + size][x + size] = digits[step];
      step += 1;
      index += 1;
      x += dir[0];
      y += dir[1];
      if (index === stride) {
        const tmp = dir[1];
        dir[1] = dir[0];
        dir[0] = -tmp;
        index = 0;
        if (dir[1] === 0) {
          stride += 1;
        }
      }
    }
    // console.log(this.table.map((x) => x.join("")).join("\n"));
  }
  private sqrt_bv(n: bigint, len: bigint): bigint {
    let sqrt = BigInt(0);
    let shift = len;
    while (shift >= BigInt(0)) {
      const tmp = ((sqrt << BigInt(1)) + (BigInt(1) << BigInt(shift))) <<
        BigInt(shift);
      if (tmp <= n) {
        sqrt += BigInt(1) << BigInt(shift);
        n -= tmp;
      }
      shift -= BigInt(1);
    }
    return sqrt;
  }
  private sqrt3_2(digits: number): number[] {
    // this is also sqrt(6 * 2 ^ 2(digits - 1))
    const num = BigInt(6) << BigInt(2 * (digits - 2));
    const res = this.sqrt_bv(num, BigInt(digits - 1));
    return res.toString(2).split("").map((x) => parseInt(x));
  }
  public decode(x: number, y: number, len: number): number[] | null {
    if (
      (x < -this.size || x + len - 1 > this.size) ||
      (y < -this.size || y > this.size)
    ) {
      return null;
    }
    return this.table[y + this.size].slice(x + this.size, x + this.size + len);
  }
  public default_rule(): Map<string, [number, number, number]> {
    const rule = new Map<string, [number, number, number]>();
    rule.set("A", [-21, -21, 4]);
    rule.set("B", [-13, -5, 6]);
    rule.set("C", [-21, 49, 5]);
    rule.set("D", [22, 11, 5]);
    rule.set("E", [4, -6, 3]);
    rule.set("F", [42, 19, 5]);
    rule.set("G", [3, 31, 6]);
    rule.set("H", [-5, 15, 4]);
    rule.set("I", [24, 11, 4]);
    rule.set("J", [-59, 34, 8]);
    rule.set("K", [72, -47, 7]);
    rule.set("L", [-18, -22, 5]);
    rule.set("M", [-47, -37, 5]);
    rule.set("N", [5, 22, 4]);
    rule.set("O", [-29, -16, 4]);
    rule.set("P", [18, 48, 6]);
    rule.set("Q", [-11, -98, 8]);
    rule.set("R", [-1, 11, 4]);
    rule.set("S", [-4, 19, 4]);
    rule.set("T", [-17, 12, 3]);
    rule.set("U", [-29, -42, 5]);
    rule.set("V", [-29, 1, 7]);
    rule.set("W", [-2, -42, 5]);
    rule.set("X", [7, 2, 8]);
    rule.set("Y", [42, -33, 6]);
    rule.set("Z", [-43, -4, 8]);
    return rule;
  }
  public default_mapping_relation(): MappingRelation {
    const rule = this.default_rule();
    const encode = new Map<string, string>();
    const decode = new Map<string, string>();
    for (const [character, [y, x, len]] of rule) {
      const rule: string = this.decode(x, y, len)!.join("");
      encode.set(character, rule);
      decode.set(rule, character);
    }
    return { encode, decode };
  }
}

interface MappingRelation {
  // from character A-Z to Nizi code(Binary)
  encode: Map<string, string>;
  // from binary to A-Z
  decode: Map<string, string>;
}

/**
 * This is the Web Code to decode sentencces.
 * The mapping rule is generated by above decoder.
 * Once you got a mapping relation, you do not need to generate it again.
 */
class WebCode {
  map: MappingRelation;
  constructor() {
    this.map = new WebDecoder().default_mapping_relation();
  }
}

Deno.test("NiziDecoder", () => {
  const wod = new WebCode();
  console.log(wod);
  // const wod = new WebDecoder(2);
});
